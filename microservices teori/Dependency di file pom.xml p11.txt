Dependency di file pom.xml


<dependency>
           <groupId>io.micrometer</groupId>
           <artifactId>micrometer-registry-prometheus</artifactId>
       </dependency>
       <dependency>
           <groupId>org.springframework.boot</groupId>
           <artifactId>spring-boot-starter-actuator</artifactId>
       </dependency>


File application.properties 




management.endpoints.web.exposure.include=health,info,prometheus
management.endpoint.prometheus.access=unrestricted
management.prometheus.metrics.export.enabled=true




File prometheus.yml 


global:
 scrape_interval: 15s
 evaluation_interval: 15s


scrape_configs:
- job_name: 'api-gateway'
 metrics_path: /actuator/prometheus
 static_configs:
 - targets: [ 'api-gateway:8080' ]


- job_name: 'product-service'
 metrics_path: /actuator/prometheus
 static_configs:
 - targets: [ 'product-service:8081' ]


- job_name: 'order-service'
 metrics_path: /actuator/prometheus
 static_configs:
 - targets: [ 'order-service:8083' ]


- job_name: 'payment-service'
 metrics_path: /actuator/prometheus
 static_configs:
 - targets: [ 'payment-service:8082' ]


- job_name: 'customer-service'
 metrics_path: /actuator/prometheus
 static_configs:
 - targets: [ 'customer-service:8084' ]


# Jika menggunakan Node Exporter untuk host metrics
- job_name: 'node-exporter'
 static_configs:
 - targets: [ 'node-exporter:9100' ]


File docker-compose.yml




services:


 api-gateway:
   build: ./api-gateway
   container_name: api-gateway
   ports:
     - "8080:8080"
   environment:
     - eureka.client.service-url.defaultZone=http://eurekaserver:8761/eureka/
   depends_on:
     - eurekaserver
   networks:
     - microservices-net


 product-service:
   build: ./product-service
   container_name: product-service
   ports:
     - "8081:8081"
   environment:
     - spring.datasource.url=jdbc:mysql://mysql:3306/dbecommerce_produk?useSSL=false&serverTimezone=UTC
     - spring.datasource.username=root
     - spring.datasource.password=root_password
     - eureka.client.service-url.defaultZone=http://eurekaserver:8761/eureka/
   depends_on:
     - eurekaserver
     - mysql
   networks:
     - microservices-net


 payment-service:
   build: ./payment-service
   container_name: payment-service
   ports:
     - "8082:8082"
   environment:
     - spring.datasource.url=jdbc:mysql://mysql:3306/dbecommerce_payment?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
     - spring.datasource.username=root
     - spring.datasource.password=root_password
     - eureka.client.service-url.defaultZone=http://eurekaserver:8761/eureka/
   depends_on:
     - eurekaserver
     - mysql
   networks:
     - microservices-net


 order-service:
   build: ./order-service
   container_name: order-service
   ports:
     - "8083:8083"
   environment:
     - spring.datasource.url=jdbc:mysql://mysql:3306/dbecommerce_orders?useSSL=false&serverTimezone=UTC
     - spring.datasource.username=root
     - spring.datasource.password=root_password
     - eureka.client.service-url.defaultZone=http://eurekaserver:8761/eureka/
     - axon.axonserver.enabled=false
   depends_on:
     - eurekaserver
     - mysql
   networks:
     - microservices-net
 customer-service:
   build: ./customer-service
   container_name: customer-service
   ports:
     - "8084:8084"
   environment:
     - spring.datasource.url=jdbc:mysql://mysql:3306/dbecommerce_customer?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
     - spring.datasource.username=root
     - spring.datasource.password=root_password
     - spring.jpa.hibernate.ddl-auto
     - eureka.client.service-url.defaultZone=http://eurekaserver:8761/eureka/
 
   depends_on:
     - eurekaserver
     - mysql
   networks:
     - microservices-net




 eurekaserver:
   build: ./eurekaserver
   container_name: eurekaserver
   ports:
     - "8761:8761"
   networks:
     - microservices-net


 rabbitmq:
   image: rabbitmq:3-management
   container_name: rabbitmq
   ports:
     - "5672:5672"
     - "15672:15672"
   networks:
     - microservices-net


 mysql:
   image: mysql:8.0
   container_name: mysql
   environment:
     MYSQL_ROOT_PASSWORD: root_password
   volumes:
     - ./mysql/init:/docker-entrypoint-initdb.d  # Mount script ke direktori init
   ports:
     - "3306:3306"
   networks:
     - microservices-net


 phpmyadmin:
   image: phpmyadmin/phpmyadmin
   container_name: phpmyadmin
   environment:
     PMA_HOST: mysql  # Nama service MySQL di Docker Compose
     PMA_PORT: 3306
     PMA_USER: root
     PMA_PASSWORD: root_password
   ports:
     - "8085:80"  # Akses phpMyAdmin via port 8085
   networks:
     - microservices-net
   depends_on:
     - mysql


 prometheus:
   image: prom/prometheus
   container_name: prometheus
   ports:
     - "9090:9090"
   volumes:
     - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
   networks:
     - microservices-net


 grafana:
   image: grafana/grafana
   container_name: grafana
   ports:
     - "3000:3000"
   environment:
     - GF_SECURITY_ADMIN_PASSWORD=admin
   networks:
     - microservices-net


 node-exporter:
   image: prom/node-exporter
   container_name: node-exporter
   ports:
     - "9100:9100"
   networks:
     - microservices-net




networks:
 microservices-net:
   driver: bridge


File grafana-deployment.yml


apiVersion: apps/v1
kind: Deployment
metadata:
 name: grafana
spec:
 replicas: 1
 selector:
   matchLabels:
     app: grafana
 template:
   metadata:
     labels:
       app: grafana
   spec:
     containers:
     - name: grafana
       image: grafana/grafana
       ports:
       - containerPort: 3000
       env:
       - name: GF_SECURITY_ADMIN_PASSWORD
         value: "admin"




File grafana-service.yml
apiVersion: v1
kind: Service
metadata:
 name: grafana
spec:
 selector:
   app: grafana
 ports:
 - protocol: TCP
   port: 3000
   targetPort: 3000
 type: NodePort


File node-exporter-deployment.yml
apiVersion: apps/v1
kind: DaemonSet
metadata:
 name: node-exporter
spec:
 selector:
   matchLabels:
     app: node-exporter
 template:
   metadata:
     labels:
       app: node-exporter
   spec:
     containers:
     - name: node-exporter
       image: prom/node-exporter
       ports:
       - containerPort: 9100
         name: metrics




File node-exporter-service.yml
apiVersion: v1
kind: Service
metadata:
 name: node-exporter
spec:
 selector:
   app: node-exporter
 ports:
 - name: metrics
   port: 9100
   targetPort: metrics


File prometheus-configmap.yml
apiVersion: v1
kind: ConfigMap
metadata:
 name: prometheus-config
 labels:
   app: prometheus
data:
 prometheus.yml: |
   global:
     scrape_interval: 15s
   scrape_configs:
     - job_name: 'api-gateway'
       static_configs:
         - targets: ['api-gateway:8080']


     - job_name: 'product-service'
       static_configs:
         - targets: ['product-service:8081']


     - job_name: 'order-service'
       static_configs:
         - targets: ['order-service:8083']


     - job_name: 'payment-service'
       static_configs:
         - targets: ['payment-service:8082']


     - job_name: 'customer-service'
       static_configs:
         - targets: ['customer-service:8084']


     - job_name: 'node'
       static_configs:
         - targets: ['node-exporter:9100']




File prometheus-deployment.yml


apiVersion: apps/v1
kind: Deployment
metadata:
 name: prometheus
 labels:
   app: prometheus
spec:
 replicas: 1
 selector:
   matchLabels:
     app: prometheus
 template:
   metadata:
     labels:
       app: prometheus
   spec:
     containers:
     - name: prometheus
       image: prom/prometheus
       ports:
       - containerPort: 9090
       volumeMounts:
       - name: prometheus-config
         mountPath: /etc/prometheus/
     volumes:
     - name: prometheus-config
       configMap:
         name: prometheus-config


File prometheus-service.yml
apiVersion: v1
kind: Service
metadata:
 name: prometheus
spec:
 selector:
   app: prometheus
 ports:
 - protocol: TCP
   port: 9090
   targetPort: 9090
 type: NodePort










Command untuk update configuration : 
docker build -t <username-dockerhub>/customer-service:versiterudpate .
docker push <username-dockerhub>/customer-service:versiterupdate


Setelah dilakukan semua service yang memiliki docker image maka lakukan restart pada setiap deployment yang ada, 
Jika ingin manual perdeployment bisa menggunakan perintah : 
kubectl rollout restart deployment namaservice


Contoh : 


kubectl rollout restart deployment product-service
kubectl rollout restart deployment customer-service


Jika ingin otomatis seluruh deployment di restart bisa menggunakan perintah : 
kubectl get deployments --all-namespaces -o name | xargs -n1 kubectl rollout restart


Untuk delete pod : 
Kubectl delete pod namapod


Untuk cek nama pod yang ada
Kubectl get pods






